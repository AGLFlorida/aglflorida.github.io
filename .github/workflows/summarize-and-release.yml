name: Summarize and Tag Release

on:
  push:
    branches: [main]
    paths-ignore:
      - '/*.md'
      - 'src/content/releases/*.md'
      - '*.yml'

permissions:
  contents: write

jobs:
  summarize:
    if: false  # Temporarily disabled
    runs-on: ubuntu-latest

    env:
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Ensure jq is installed
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Get Latest Git Tag or First Commit
        id: latest_tag
        run: |
          if git describe --tags --abbrev=0 > /dev/null 2>&1; then
            echo "tag=$(git describe --tags --abbrev=0)" >> $GITHUB_OUTPUT
          else
            echo "tag=$(git rev-list --max-parents=0 HEAD)" >> $GITHUB_OUTPUT
          fi

      - name: Get Commit Messages Since Last Tag
        id: commit_log
        run: |
          if git describe --tags --abbrev=0 >/dev/null 2>&1; then
            latest_tag=$(git describe --tags --abbrev=0)
          else
            latest_tag=$(git rev-list --max-parents=0 HEAD)
          fi

          if git tag --list | grep -q "$latest_tag"; then
            commit_log=$(git log "$latest_tag"..HEAD --pretty=format:"%s")
          else
            commit_log=$(git log --pretty=format:"%s")
          fi

          printf "%s\n" "$commit_log" > commit_log.txt
          echo "log_path=commit_log.txt" >> $GITHUB_OUTPUT

      - name: Prepare Prompt and Query Gemini API
        id: summary
        run: |
          # Preprocess commit log: filter merge commits and clean up
          filtered_log=$(mktemp)
          while IFS= read -r line; do
            # Skip merge commits and empty lines
            if [[ "$line" == Merge* ]] || [[ -z "$line" ]]; then
              continue
            fi
            # Strip emoji-style colons like :shipit:
            line_clean=$(echo "$line" | sed -E 's/:[^[:space:]]+://g')
            echo "$line_clean" >> "$filtered_log"
          done < "${{ steps.commit_log.outputs.log_path }}"
          
          # Replace the COMMIT_MESSAGES placeholder in the prompt with actual commit messages
          # Using jq to read both files and perform the replacement
          # The placeholder pattern needs proper escaping for jq's gsub function
          prompt_json=$(jq -n \
            --rawfile prompt_template ".templates/gemini-prompt.txt" \
            --rawfile commit_list "$filtered_log" \
            '{
              contents: [{
                parts: [{
                  text: ($prompt_template | gsub("COMMIT_MESSAGES: \\[commit messages here\\]"; "COMMIT_MESSAGES:\n" + $commit_list))
                }]
              }]
            }')
          
          rm "$filtered_log"
          
          # Send request to Gemini API
          response_and_status=$(mktemp)
          http_code=$(curl -sS --retry 2 --max-time 60 -w "%{http_code}" -o "$response_and_status" \
            -H "Content-Type: application/json" \
            -H "X-goog-api-key: ${GEMINI_API_KEY}" \
            -X POST \
            -d "$prompt_json" \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent")
          
          response=$(cat "$response_and_status")
          rm "$response_and_status"
          
          if [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
            # Extract the generated text from Gemini API response
            summary=$(echo "$response" | jq -r '.candidates[0].content.parts[0].text // empty')
            
            if [[ -n "$summary" ]]; then
              # Clean up any markdown formatting that might interfere
              summary=$(echo "$summary" | sed 's/^#* //' | sed 's/\*\*//g')
              summary="${summary}"$'\n\nGenerated by Google Gemini Pro'
            else
              echo "Warning: Empty response from Gemini API, using fallback"
              summary=""
            fi
          else
            echo "--- FALLBACK: Gemini API returned status $http_code, using local summarizer ---"
            summary=""
          fi
          
          # Fallback to local summarizer if Gemini API failed or returned empty
          if [[ -z "$summary" ]]; then
            echo "--- FALLBACK: Using most recent commit message ---"
            # Get the most recent non-merge commit message
            if git describe --tags --abbrev=0 >/dev/null 2>&1; then
              latest_tag=$(git describe --tags --abbrev=0)
              recent_commit=$(git log "$latest_tag"..HEAD --pretty=format:"%s" --no-merges | head -n 1)
            else
              recent_commit=$(git log --pretty=format:"%s" --no-merges | head -n 1)
            fi
            
            if [[ -n "$recent_commit" ]]; then
              # Strip emoji-style colons like :shipit:
              summary=$(echo "$recent_commit" | sed -E 's/:[^[:space:]]+://g')
            else
              # Last resort: get any commit message
              summary=$(git log -1 --pretty=format:"%s" --no-merges)
              if [[ -z "$summary" ]]; then
                summary=$(git log -1 --pretty=format:"%s")
              fi
            fi
            
            # Append note that AI API call failed
            summary="${summary}"$'\n\nNote: AI-generated summary unavailable, using most recent commit message.'
          fi
          
          printf "%s\n" "$summary" > summary.txt
          echo "summary_file=summary.txt" >> $GITHUB_OUTPUT
          cat summary.txt

      - name: Skip if Summary Is Empty
        id: skip_check
        run: |
          if [ ! -s summary.txt ]; then
            echo "No summary to commit or tag. Exiting."
            echo "should_skip=true" >> $GITHUB_OUTPUT
          else 
            echo "should_skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Blog Post Markdown from Template
        id: release 
        if: steps.skip_check.outputs.should_skip == 'false'
        run: |
          today=$(date +'%Y%b%d-%H%M%S')
          iso_date=$(date -Iseconds)
          release_path="src/content/releases/releasenotes-${today}.md"
          summary=$(cat "${{ steps.summary.outputs.summary_file }}")

          # Escape forward slashes and ampersands for safe sed injection
          escaped_summary=$(printf '%s\n' "$summary" | sed -e 's/[\/&]/\\&/g')

          sed -e "s/{{ date }}/$today/" \
              -e "s/{{ iso_date }}/$iso_date/" \
              .templates/release-note-template.md > "$release_path"

          awk -v summary="$summary" '
            {
              if ($0 ~ /{{ summary }}/) {
                print summary
              } else {
                print $0
              }
            }
          ' "$release_path" > "${release_path}.tmp" && mv "${release_path}.tmp" "$release_path"

          echo "release_path=$release_path" >> $GITHUB_OUTPUT

      - name: Configure Git user
        run: |
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Commit and Push Release Post
        if: steps.skip_check.outputs.should_skip == 'false'
        run: |
          git add "${{ steps.release.outputs.release_path }}"
          
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          
          commit_message="docs: add release notes for ${{ steps.release.outputs.release_path }}"
          sanitized_message=$(echo "$commit_message" | tr -d '\n' | sed 's/[^[:print:]]//g')
          git commit -m "$sanitized_message"
          git push

      - name: Compute Next Version
        id: version
        run: |
          current_tag="${{ steps.latest_tag.outputs.tag }}"
          if [[ "$current_tag" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            major="${BASH_REMATCH[1]}"
            minor="${BASH_REMATCH[2]}"
            patch="${BASH_REMATCH[3]}"
            new_tag="v$major.$((minor + 1)).0"
          else
            new_tag="v0.1.0"
          fi
          echo "tag=$new_tag" >> $GITHUB_OUTPUT

      - name: Tag Release Commit
        run: |
          tag="${{ steps.version.outputs.tag }}"
          
          if git rev-parse "$tag" >/dev/null 2>&1; then
            echo "Tag $tag already exists. Skipping."
            exit 0
          fi

          git tag -a "$tag" -m "Release $tag"
          git push origin "$tag"
