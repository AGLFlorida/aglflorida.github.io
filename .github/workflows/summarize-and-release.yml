name: Summarize and Tag Release

on:
  push:
    branches: [main]
    paths-ignore:
      - '/*.md'

jobs:
  summarize:
    runs-on: ubuntu-latest

    env:
      HF_API_ENDPOINT: ${{ vars.HUGGINGFACE_API_ENDPOINT }}
      HF_API_KEY: ${{ secrets.HUGGINGFACE_API_KEY }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Ensure jq is installed
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Get Latest Git Tag or First Commit
        id: latest_tag
        run: |
          if git describe --tags --abbrev=0 > /dev/null 2>&1; then
            echo "tag=$(git describe --tags --abbrev=0)" >> $GITHUB_OUTPUT
          else
            echo "tag=$(git rev-list --max-parents=0 HEAD)" >> $GITHUB_OUTPUT
          fi

      - name: Get Commit Messages Since Last Tag
        id: commit_log
        run: |
          if git tag --list | grep -q "${{ steps.latest_tag.outputs.tag }}"; then
            raw_log=$(git log "${{ steps.latest_tag.outputs.tag }}"..HEAD --pretty=format:"%s")
          else
            raw_log=$(git log --pretty=format:"%s")
          fi

          clean_log=$(echo "$raw_log" | grep -v '^Merge' | sed -E 's/[\x{1F600}-\x{1F6FF}\x{2600}-\x{26FF}]//gu')
          if [ -z "$clean_log" ]; then
            echo "No new commits to summarize. Exiting."
            exit 0
          fi

          printf "%s\n" "$clean_log" > commit_log.txt
          echo "log_path=commit_log.txt" >> $GITHUB_OUTPUT

      - name: Prepare Prompt and Query Model
        id: summary
        run: |
          prompt="Summarize the following commit messages into a single paragraph suitable for a press release:\n"
          input="$prompt"
          while IFS= read -r line; do
            input+="- $line\n"
          done < "${{ steps.commit_log.outputs.log_path }}"

          json=$(jq -n --arg txt "$input" '{inputs: $txt}')

          response_file=$(mktemp)
          http_code=$(curl -sS -w "%{http_code}" -o "$response_file" \
            -H "Authorization: Bearer $HF_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$json" "$HF_API_ENDPOINT")

          if [[ "$http_code" =~ ^2 ]]; then
            summary=$(jq -r '.[0].generated_text // .[0].summary_text // empty' "$response_file")
          else
            summary="This release includes:"
            while IFS= read -r line; do
              case "$line" in
                feat:*) summary+=$'\n'"- Added: ${line#feat: }" ;;
                fix:*) summary+=$'\n'"- Fixed: ${line#fix: }" ;;
                chore:*) summary+=$'\n'"- Maintenance: ${line#chore: }" ;;
                docs:*) summary+=$'\n'"- Docs updated: ${line#docs: }" ;;
              esac
            done < "${{ steps.commit_log.outputs.log_path }}"
          fi

          printf "%s\n" "$summary" > summary.txt
          echo "summary_file=summary.txt" >> $GITHUB_OUTPUT

      - name: Create Blog Post Markdown from Template
        id: blog
        run: |
          today=$(date +'%Y%b%d')
          iso_date=$(date -Iseconds)
          blog_path="src/content/blog/releasenotes-${today}.md"
          summary=$(cat "${{ steps.summary.outputs.summary_file }}")

          # Escape forward slashes and ampersands for safe sed injection
          escaped_summary=$(printf '%s\n' "$summary" | sed -e 's/[\/&]/\\&/g')

          sed -e "s/{{ date }}/$today/" \
              -e "s/{{ iso_date }}/$iso_date/" \
              -e "s/{{ summary }}/$escaped_summary/" \
              .templates/release-note-template.md > "$blog_path"

          echo "blog_path=$blog_path" >> $GITHUB_OUTPUT

      - name: Commit and Push Blog Post
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add "${{ steps.blog.outputs.blog_path }}"
          commit_message="docs: add release notes for ${{ steps.blog.outputs.blog_path }}"
          sanitized_message=$(echo "$commit_message" | tr -d '\n' | sed 's/[^[:print:]]//g')
          git commit -m "$sanitized_message"
          git push

      - name: Compute Next Version
        id: version
        run: |
          current_tag="${{ steps.latest_tag.outputs.tag }}"
          if [[ "$current_tag" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            major="${BASH_REMATCH[1]}"
            minor="${BASH_REMATCH[2]}"
            patch="${BASH_REMATCH[3]}"
            new_tag="v$major.$((minor + 1)).0"
          else
            new_tag="v0.1.0"
          fi
          echo "tag=$new_tag" >> $GITHUB_OUTPUT

      - name: Tag Release Commit
        run: |
          commit_sha=$(git rev-parse HEAD)
          git tag -a "${{ steps.version.outputs.tag }}" -m "Release ${{ steps.version.outputs.tag }}" "$commit_sha"
          git push origin "${{ steps.version.outputs.tag }}"
